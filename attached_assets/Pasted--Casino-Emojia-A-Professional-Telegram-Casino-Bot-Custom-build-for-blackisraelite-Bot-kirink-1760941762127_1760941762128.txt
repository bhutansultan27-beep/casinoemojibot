"""
Casino Emojia - A Professional Telegram Casino Bot
Custom build for @blackisraelite
Bot: @kirinkasinobot

Requirements:
- Python 3.9+
- python-telegram-bot v20.x
- Install: pip3 install python-telegram-bot==20.7

Setup:
1. Save this file as: casino_bot.py
2. Install dependency: pip3 install python-telegram-bot==20.7
3. Run: python3 casino_bot.py

Note: This is a simulation - no real crypto transactions occur.
"""

import asyncio
import random
import time
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple
from collections import defaultdict
import logging

from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import (
    Application,
    CommandHandler,
    CallbackQueryHandler,
    MessageHandler,
    ContextTypes,
    filters
)

# Configure logging
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# ==================== CONFIGURATION ====================
# Bot token for @kirinkasinobot (saved for @blackisraelite)
BOT_TOKEN = "8218366688:AAHsYsgu_Y5VDzp_8Y1zJAdQVav-tiiB4cA"
MAIN_GROUP_ID = None  # Set this to your group chat ID after first message
LTC_RATE = 77.0  # $77 per LTC
DEPOSIT_FEE = 0.01  # 1% fee
CONFIRMATION_DELAY = 5  # 5 seconds for testing (change to 120 for production)

# Rate limiting
RATE_LIMIT_WINDOW = 60  # seconds
RATE_LIMIT_MAX = 10  # max actions per window

# ==================== IN-MEMORY DATABASE ====================
class CasinoDatabase:
    """Simulated in-memory database for all casino operations"""
    
    def __init__(self):
        self.users: Dict[int, Dict] = {}  # user_id -> user data
        self.pending_deposits: Dict[str, Dict] = {}  # txid -> deposit data
        self.active_games: Dict[str, Dict] = {}  # game_id -> game state
        self.leaderboard: List[Tuple[int, float]] = []  # (user_id, balance)
        self.rate_limits: Dict[int, List[float]] = defaultdict(list)  # user_id -> timestamps
        self.jackpot_pool = 5000.0  # Starting jackpot
        
    def get_user(self, user_id: int) -> Dict:
        """Get or create user data"""
        if user_id not in self.users:
            self.users[user_id] = {
                'balance': 999999999.0,  # Infinite balance - $999,999,999 to start!
                'username': '',
                'total_wagered': 0.0,
                'total_won': 0.0,
                'games_played': 0,
                'last_bonus': None,
                'bonus_streak': 0,
                'ltc_address': f"LTC{random.randint(100000, 999999)}xyz"
            }
        return self.users[user_id]
    
    def check_rate_limit(self, user_id: int) -> bool:
        """Check if user is within rate limits"""
        now = time.time()
        # Clean old timestamps
        self.rate_limits[user_id] = [
            ts for ts in self.rate_limits[user_id] 
            if now - ts < RATE_LIMIT_WINDOW
        ]
        
        if len(self.rate_limits[user_id]) >= RATE_LIMIT_MAX:
            return False
        
        self.rate_limits[user_id].append(now)
        return True
    
    def update_leaderboard(self):
        """Update leaderboard rankings"""
        self.leaderboard = sorted(
            [(uid, data['balance']) for uid, data in self.users.items()],
            key=lambda x: x[1],
            reverse=True
        )[:10]

# Initialize database
db = CasinoDatabase()

# ==================== GAME LOGIC ====================
class RouletteGame:
    """ğŸ° Roulette game mechanics"""
    
    RED_NUMBERS = [1, 3, 5, 7, 9, 12, 14, 16, 18, 19, 21, 23, 25, 27, 30, 32, 34, 36]
    BLACK_NUMBERS = [2, 4, 6, 8, 10, 11, 13, 15, 17, 20, 22, 24, 26, 28, 29, 31, 33, 35]
    
    @staticmethod
    def spin() -> int:
        """Spin the wheel (0-36)"""
        return random.randint(0, 36)
    
    @staticmethod
    def get_color(number: int) -> str:
        """Get color of number"""
        if number == 0:
            return "ğŸŸ¢"
        return "ğŸ”´" if number in RouletteGame.RED_NUMBERS else "âš«"
    
    @staticmethod
    def calculate_payout(bet_type: str, bet_number: Optional[int], result: int, amount: float) -> float:
        """Calculate payout based on bet type and result"""
        if bet_type == "number" and bet_number == result:
            return amount * 35  # 35:1
        elif bet_type == "red" and result in RouletteGame.RED_NUMBERS:
            return amount  # 1:1
        elif bet_type == "black" and result in RouletteGame.BLACK_NUMBERS:
            return amount  # 1:1
        elif bet_type == "odd" and result % 2 == 1 and result != 0:
            return amount  # 1:1
        elif bet_type == "even" and result % 2 == 0 and result != 0:
            return amount  # 1:1
        elif bet_type == "dozen":
            if bet_number == 1 and 1 <= result <= 12:
                return amount * 2  # 2:1
            elif bet_number == 2 and 13 <= result <= 24:
                return amount * 2
            elif bet_number == 3 and 25 <= result <= 36:
                return amount * 2
        return 0.0


class BlackjackGame:
    """ğŸƒ Simplified Blackjack mechanics"""
    
    CARD_VALUES = {
        'A': 11, '2': 2, '3': 3, '4': 4, '5': 5,
        '6': 6, '7': 7, '8': 8, '9': 9, '10': 10,
        'J': 10, 'Q': 10, 'K': 10
    }
    
    @staticmethod
    def deal_card() -> str:
        """Deal a random card"""
        return random.choice(list(BlackjackGame.CARD_VALUES.keys()))
    
    @staticmethod
    def calculate_hand_value(cards: List[str]) -> int:
        """Calculate hand value with ace handling"""
        value = sum(BlackjackGame.CARD_VALUES[card] for card in cards)
        aces = cards.count('A')
        
        # Adjust for aces
        while value > 21 and aces > 0:
            value -= 10
            aces -= 1
        
        return value
    
    @staticmethod
    def is_blackjack(cards: List[str]) -> bool:
        """Check if hand is blackjack"""
        return len(cards) == 2 and BlackjackGame.calculate_hand_value(cards) == 21


class BasketballGame:
    """ğŸ€ Basketball free throw mechanics"""
    
    @staticmethod
    def shoot() -> bool:
        """Simulate free throw (55% success rate)"""
        return random.random() < 0.55
    
    @staticmethod
    def calculate_payout(prediction: str, result: bool, amount: float) -> float:
        """Calculate payout (1.8:1 for correct prediction)"""
        if (prediction == "score" and result) or (prediction == "miss" and not result):
            return amount * 1.8
        return 0.0


class SoccerGame:
    """âš½ Soccer penalty kick mechanics"""
    
    @staticmethod
    def kick() -> bool:
        """Simulate penalty kick (45% goal rate)"""
        return random.random() < 0.45
    
    @staticmethod
    def calculate_payout(prediction: str, result: bool, amount: float) -> float:
        """Calculate payout (2:1 for correct prediction)"""
        if (prediction == "goal" and result) or (prediction == "save" and not result):
            return amount * 2
        return 0.0


class BowlingGame:
    """ğŸ³ Bowling mechanics with progressive jackpot"""
    
    @staticmethod
    def roll() -> str:
        """Simulate bowling roll"""
        roll = random.random()
        if roll < 0.10:  # 10% strike
            return "strike"
        elif roll < 0.50:  # 40% spare
            return "spare"
        return "miss"  # 50% miss
    
    @staticmethod
    def calculate_payout(prediction: str, result: str, amount: float) -> float:
        """Calculate payout (20:1 for strike, 1:1 for spare)"""
        if prediction == "strike" and result == "strike":
            return amount * 20
        elif prediction == "spare" and result in ["spare", "miss"]:
            return amount
        return 0.0


# ==================== COMMAND HANDLERS ====================
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle /start command"""
    user = update.effective_user
    user_data = db.get_user(user.id)
    user_data['username'] = user.username or user.first_name
    
    welcome_msg = (
        f"ğŸ° Welcome to Casino Emojia, {user.first_name}! ğŸ°\n\n"
        "ğŸ² Your premier crypto casino experience on Telegram.\n\n"
        "ğŸ’° <b>Getting Started:</b>\n"
        "â€¢ Use /bonus to get free money to start!\n"
        "â€¢ Use /balance to check your balance\n"
        "â€¢ Use /deposit to add funds (LTC â†’ $)\n\n"
        "ğŸ® <b>Available Games:</b>\n"
        "ğŸ° /roulette - Classic roulette\n"
        "ğŸƒ /blackjack - 21 card game\n"
        "ğŸ€ /basketball - Free throw bets\n"
        "âš½ /soccer - Penalty kick bets\n"
        "ğŸ³ /bowling - Strike for jackpot!\n\n"
        "ğŸ† /leaderboard - See top players\n\n"
        "ğŸ’¡ <b>Tip:</b> Start with /bonus for free money!\n\n"
        "Good luck! ğŸ€"
    )
    
    await update.message.reply_text(welcome_msg, parse_mode='HTML')


async def deposit(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle /deposit command"""
    user_id = update.effective_user.id
    user_data = db.get_user(user_id)
    
    address = user_data['ltc_address']
    
    msg = (
        f"ğŸ’³ <b>Deposit Litecoin</b>\n\n"
        f"Send LTC to this address:\n"
        f"<code>{address}</code>\n\n"
        f"ğŸ“Š Current rate: ${LTC_RATE:.2f} per LTC\n"
        f"ğŸ’µ Fee: {DEPOSIT_FEE*100}%\n\n"
        f"After sending, confirm with:\n"
        f"/confirm [transaction_id]\n\n"
        f"Example: /confirm abc123\n\n"
        f"â± Confirmation takes ~5 seconds (demo mode)."
    )
    
    await update.message.reply_text(msg, parse_mode='HTML')


async def confirm_deposit(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle /confirm [txid] command"""
    user_id = update.effective_user.id
    
    if not context.args:
        await update.message.reply_text("âŒ Please provide transaction ID:\n\n/confirm [txid]\n\nExample: /confirm abc123")
        return
    
    txid = context.args[0]
    
    # Simulate random deposit amount (0.1 to 1.0 LTC)
    ltc_amount = random.uniform(0.1, 1.0)
    usd_amount = ltc_amount * LTC_RATE
    fee = usd_amount * DEPOSIT_FEE
    final_amount = usd_amount - fee
    
    # Store pending deposit
    db.pending_deposits[txid] = {
        'user_id': user_id,
        'amount': final_amount,
        'timestamp': time.time()
    }
    
    await update.message.reply_text(
        f"â³ Deposit pending confirmation...\n"
        f"Amount: ${usd_amount:.2f} ({ltc_amount:.3f} LTC)\n"
        f"Fee: ${fee:.2f}\n"
        f"You'll receive: ${final_amount:.2f}\n\n"
        f"Please wait ~5 seconds..."
    )
    
    # Simulate blockchain confirmation delay
    await asyncio.sleep(CONFIRMATION_DELAY)
    
    # Credit user account
    user_data = db.get_user(user_id)
    user_data['balance'] += final_amount
    
    await context.bot.send_message(
        chat_id=user_id,
        text=(
            f"âœ… <b>Deposit Confirmed!</b>\n\n"
            f"ğŸ’° Received: ${final_amount:.2f}\n"
            f"ğŸ’³ Balance: ${user_data['balance']:.2f}\n\n"
            f"Ready to play! Try /roulette to start."
        ),
        parse_mode='HTML'
    )


async def balance(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle /balance command"""
    user_id = update.effective_user.id
    user_data = db.get_user(user_id)
    
    msg = (
        f"ğŸ’° <b>Your Balance</b>\n\n"
        f"ğŸ’µ ${user_data['balance']:.2f}\n"
        f"ğŸ® Games played: {user_data['games_played']}\n"
        f"ğŸ’¸ Total wagered: ${user_data['total_wagered']:.2f}\n"
        f"ğŸ† Total won: ${user_data['total_won']:.2f}\n\n"
        f"Use /deposit to add funds\n"
        f"Use /bonus for daily free money\n"
        f"Use /withdraw to cash out"
    )
    
    await update.message.reply_text(msg, parse_mode='HTML')


async def withdraw(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle /withdraw [amount] command"""
    user_id = update.effective_user.id
    user_data = db.get_user(user_id)
    
    if not context.args:
        await update.message.reply_text("âŒ Usage: /withdraw [amount]\n\nExample: /withdraw 50")
        return
    
    try:
        amount = float(context.args[0])
    except ValueError:
        await update.message.reply_text("âŒ Invalid amount. Use numbers only.")
        return
    
    if amount <= 0:
        await update.message.reply_text("âŒ Amount must be greater than 0.")
        return
    
    if amount > user_data['balance']:
        await update.message.reply_text(
            f"âŒ Insufficient balance.\nğŸ’° Available: ${user_data['balance']:.2f}"
        )
        return
    
    # Calculate withdrawal
    fee = amount * DEPOSIT_FEE
    final_usd = amount - fee
    ltc_amount = final_usd / LTC_RATE
    
    # Deduct from balance
    user_data['balance'] -= amount
    
    msg = (
        f"âœ… <b>Withdrawal Processed</b>\n\n"
        f"ğŸ’¸ Amount: ${amount:.2f}\n"
        f"ğŸ’µ Fee: ${fee:.2f}\n"
        f"ğŸ’° Sent: ~{ltc_amount:.4f} LTC\n"
        f"ğŸ“ To: {user_data['ltc_address']}\n\n"
        f"ğŸ’³ Remaining balance: ${user_data['balance']:.2f}"
    )
    
    await update.message.reply_text(msg, parse_mode='HTML')


async def roulette_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle /roulette command"""
    user_id = update.effective_user.id
    user_data = db.get_user(user_id)
    
    if not db.check_rate_limit(user_id):
        await update.message.reply_text("â± Slow down! Please wait before placing another bet.")
        return
    
    keyboard = [
        [InlineKeyboardButton("ğŸ”´ Red", callback_data="roulette_red"),
         InlineKeyboardButton("âš« Black", callback_data="roulette_black")],
        [InlineKeyboardButton("Odd", callback_data="roulette_odd"),
         InlineKeyboardButton("Even", callback_data="roulette_even")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    msg = (
        "ğŸ° <b>ROULETTE</b>\n\n"
        f"ğŸ’° Your balance: ${user_data['balance']:.2f}\n\n"
        "Select your bet type:\n"
        "ğŸ”´ Red/âš« Black - 1:1 payout\n"
        "Odd/Even - 1:1 payout\n\n"
        "After selecting, type your bet amount\n"
        "Example: 10"
    )
    
    await update.message.reply_text(msg, reply_markup=reply_markup, parse_mode='HTML')


async def basketball_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle /basketball command"""
    user_id = update.effective_user.id
    user_data = db.get_user(user_id)
    
    if not db.check_rate_limit(user_id):
        await update.message.reply_text("â± Slow down! Please wait before placing another bet.")
        return
    
    keyboard = [
        [InlineKeyboardButton("ğŸ€ Score", callback_data="basketball_score"),
         InlineKeyboardButton("âŒ Miss", callback_data="basketball_miss")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    msg = (
        "ğŸ€ <b>BASKETBALL FREE THROW</b>\n\n"
        f"ğŸ’° Your balance: ${user_data['balance']:.2f}\n\n"
        "Bet on the free throw outcome:\n"
        "ğŸ€ Score - 1.8:1 payout (55% chance)\n"
        "âŒ Miss - 1.8:1 payout (45% chance)\n\n"
        "After selecting, type your bet amount\n"
        "Example: 20"
    )
    
    await update.message.reply_text(msg, reply_markup=reply_markup, parse_mode='HTML')


async def soccer_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle /soccer command"""
    user_id = update.effective_user.id
    user_data = db.get_user(user_id)
    
    if not db.check_rate_limit(user_id):
        await update.message.reply_text("â± Slow down! Please wait before placing another bet.")
        return
    
    keyboard = [
        [InlineKeyboardButton("âš½ Goal", callback_data="soccer_goal"),
         InlineKeyboardButton("ğŸ§¤ Save", callback_data="soccer_save")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    msg = (
        "âš½ <b>SOCCER PENALTY KICK</b>\n\n"
        f"ğŸ’° Your balance: ${user_data['balance']:.2f}\n\n"
        "Bet on the penalty outcome:\n"
        "âš½ Goal - 2:1 payout (45% chance)\n"
        "ğŸ§¤ Save - 2:1 payout (55% chance)\n\n"
        "After selecting, type your bet amount\n"
        "Example: 15"
    )
    
    await update.message.reply_text(msg, reply_markup=reply_markup, parse_mode='HTML')


async def bowling_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle /bowling command"""
    user_id = update.effective_user.id
    user_data = db.get_user(user_id)
    
    if not db.check_rate_limit(user_id):
        await update.message.reply_text("â± Slow down! Please wait before placing another bet.")
        return
    
    keyboard = [
        [InlineKeyboardButton("ğŸ³ Strike", callback_data="bowling_strike"),
         InlineKeyboardButton("ğŸ“ Spare/Miss", callback_data="bowling_spare")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    msg = (
        "ğŸ³ <b>BOWLING JACKPOT</b>\n\n"
        f"ğŸ’° Your balance: ${user_data['balance']:.2f}\n"
        f"ğŸ† Jackpot: ${db.jackpot_pool:.2f}\n\n"
        "Bet on the roll:\n"
        "ğŸ³ Strike - 20:1 payout (10% chance)\n"
        "ğŸ“ Spare/Miss - 1:1 payout (90% chance)\n\n"
        "ğŸ’ 3 strikes in a row = JACKPOT!\n\n"
        "After selecting, type your bet amount\n"
        "Example: 25"
    )
    
    await update.message.reply_text(msg, reply_markup=reply_markup, parse_mode='HTML')


async def blackjack_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle /blackjack command"""
    user_id = update.effective_user.id
    user_data = db.get_user(user_id)
    
    if not db.check_rate_limit(user_id):
        await update.message.reply_text("â± Slow down! Please wait before placing another bet.")
        return
    
    keyboard = [
        [InlineKeyboardButton("Bet $10", callback_data="blackjack_10"),
         InlineKeyboardButton("Bet $25", callback_data="blackjack_25"),
         InlineKeyboardButton("Bet $50", callback_data="blackjack_50")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    msg = (
        "ğŸƒ <b>BLACKJACK</b>\n\n"
        f"ğŸ’° Your balance: ${user_data['balance']:.2f}\n\n"
        "Beat the dealer to 21!\n"
        "ğŸ° Blackjack - 3:2 payout\n"
        "âœ… Win - 1:1 payout\n\n"
        "Select your bet:"
    )
    
    await update.message.reply_text(msg, reply_markup=reply_markup, parse_mode='HTML')


async def leaderboard(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Show leaderboard"""
    db.update_leaderboard()
    
    if not db.leaderboard:
        await update.message.reply_text("ğŸ† Leaderboard is empty. Be the first to play!")
        return
    
    msg = "ğŸ† <b>CASINO EMOJIA LEADERBOARD</b>\n\n"
    msg += "Top 10 Players:\n\n"
    
    medals = ["ğŸ¥‡", "ğŸ¥ˆ", "ğŸ¥‰"]
    
    for idx, (user_id, balance) in enumerate(db.leaderboard, 1):
        user_data = db.get_user(user_id)
        medal = medals[idx-1] if idx <= 3 else f"{idx}."
        username = user_data.get('username', 'Anonymous')
        msg += f"{medal} @{username}: ${balance:.2f}\n"
    
    msg += "\nğŸ’° Weekly prizes:\n1st: $1,000 | 2nd: $500 | 3rd: $250"
    
    await update.message.reply_text(msg, parse_mode='HTML')


async def daily_bonus(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle /bonus command"""
    user_id = update.effective_user.id
    user_data = db.get_user(user_id)
    
    now = datetime.now()
    last_bonus = user_data.get('last_bonus')
    
    # Check if already claimed today
    if last_bonus and (now - last_bonus).total_seconds() < 86400:  # 24 hours
        next_bonus = last_bonus + timedelta(days=1)
        hours_left = int((next_bonus - now).total_seconds() / 3600)
        await update.message.reply_text(
            f"â° Daily bonus already claimed!\n"
            f"Come back in {hours_left} hours."
        )
        return
    
    # Update streak
    if last_bonus and (now - last_bonus).days == 1:
        user_data['bonus_streak'] += 1
    else:
        user_data['bonus_streak'] = 1
    
    user_data['last_bonus'] = now
    
    # Random bonus
    bonus_amount = random.uniform(10, 100)
    user_data['balance'] += bonus_amount
    
    msg = f"ğŸ <b>Daily Bonus!</b>\n\n"
    msg += f"ğŸ’° You received: ${bonus_amount:.2f}\n"
    msg += f"ğŸ’³ Balance: ${user_data['balance']:.2f}\n"
    msg += f"ğŸ”¥ Streak: {user_data['bonus_streak']} days\n\n"
    
    # Streak bonus
    if user_data['bonus_streak'] == 5:
        streak_bonus = 200
        user_data['balance'] += streak_bonus
        msg += f"ğŸ‰ 5-day streak bonus: ${streak_bonus}!\n"
        user_data['bonus_streak'] = 0
    
    msg += "\nğŸ€ Come back tomorrow!"
    
    await update.message.reply_text(msg, parse_mode='HTML')


# ==================== CALLBACK HANDLERS ====================
async def handle_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle button callbacks"""
    query = update.callback_query
    await query.answer()
    
    user_id = query.from_user.id
    user_data = db.get_user(user_id)
    data = query.data
    
    # Store game state in context
    if 'game_state' not in context.user_data:
        context.user_data['game_state'] = {}
    
    # Roulette callbacks
    if data.startswith("roulette_"):
        bet_type = data.split("_")[1]
        context.user_data['game_state']['type'] = 'roulette'
        context.user_data['game_state']['bet_type'] = bet_type
        
        await query.edit_message_text(
            f"ğŸ° Roulette - {bet_type.upper()} selected\n\n"
            f"Now enter your bet amount:\n\n"
            f"Example: 10\n"
            f"(This will bet $10 on {bet_type})"
        )
    
    # Basketball callbacks
    elif data.startswith("basketball_"):
        prediction = data.split("_")[1]
        context.user_data['game_state']['type'] = 'basketball'
        context.user_data['game_state']['prediction'] = prediction
        
        await query.edit_message_text(
            f"ğŸ€ Free Throw - {prediction.upper()} selected\n\n"
            f"Now enter your bet amount:\n\n"
            f"Example: 20"
        )
    
    # Soccer callbacks
    elif data.startswith("soccer_"):
        prediction = data.split("_")[1]
        context.user_data['game_state']['type'] = 'soccer'
        context.user_data['game_state']['prediction'] = prediction
        
        await query.edit_message_text(
            f"âš½ Penalty - {prediction.upper()} selected\n\n"
            f"Now enter your bet amount:\n\n"
            f"Example: 15"
        )
    
    # Bowling callbacks
    elif data.startswith("bowling_"):
        prediction = data.split("_")[1]
        context.user_data['game_state']['type'] = 'bowling'
        context.user_data['game_state']['prediction'] = prediction
        
        await query.edit_message_text(
            f"ğŸ³ Bowling - {prediction.upper()} selected\n\n"
            f"Now enter your bet amount:\n\n"
            f"Example: 25"
        )
    
    # Blackjack callbacks
    elif data.startswith("blackjack_"):
        if data == "blackjack_hit":
            # Hit - deal another card
            game_state = context.user_data.get('blackjack_hand', {})
            if not game_state:
                await query.edit_message_text("âŒ No active game. Start with /blackjack")
                return
                
            player_cards = game_state.get('player_cards', [])
            new_card = BlackjackGame.deal_card()
            player_cards.append(new_card)
            
            player_value = BlackjackGame.calculate_hand_value(player_cards)
            dealer_cards = game_state['dealer_cards']
            
            if player_value > 21:
                # Bust
                bet_amount = game_state['bet']
                user_data['balance'] -= bet_amount
                user_data['total_wagered'] += bet_amount
                user_data['games_played'] += 1
                msg = (
                    f"ğŸƒ <b>BLACKJACK - BUST</b>\n\n"
                    f"Your cards: {' '.join(player_cards)} = {player_value}\n"
                    f"Dealer: {' '.join(dealer_cards)}\n\n"
                    f"ğŸ’¥ BUST! You lose ${bet_amount:.2f}\n"
                    f"ğŸ’³ Balance: ${user_data['balance']:.2f}"
                )
                await query.edit_message_text(msg, parse_mode='HTML')
                del context.user_data['blackjack_hand']
            else:
                # Continue playing
                keyboard = [
                    [InlineKeyboardButton("ğŸ´ Hit", callback_data="blackjack_hit"),
                     InlineKeyboardButton("âœ‹ Stand", callback_data="blackjack_stand")]
                ]
                reply_markup = InlineKeyboardMarkup(keyboard)
                
                msg = (
                    f"ğŸƒ <b>BLACKJACK</b>\n\n"
                    f"Your cards: {' '.join(player_cards)} = {player_value}\n"
                    f"Dealer: {dealer_cards[0]} ?\n\n"
                    f"What's your move?"
                )
                await query.edit_message_text(msg, reply_markup=reply_markup, parse_mode='HTML')
                context.user_data['blackjack_hand'] = game_state
        
        elif data == "blackjack_stand":
            # Stand - dealer plays
            game_state = context.user_data.get('blackjack_hand', {})
            if not game_state:
                await query.edit_message_text("âŒ No active game. Start with /blackjack")
                return
                
            player_cards = game_state['player_cards']
            dealer_cards = game_state['dealer_cards']
            bet_amount = game_state['bet']
            
            # Dealer draws until 17+
            while BlackjackGame.calculate_hand_value(dealer_cards) < 17:
                dealer_cards.append(BlackjackGame.deal_card())
            
            player_value = BlackjackGame.calculate_hand_value(player_cards)
            dealer_value = BlackjackGame.calculate_hand_value(dealer_cards)
            
            # Determine winner
            if dealer_value > 21:
                # Dealer bust - player wins
                winnings = bet_amount
                user_data['balance'] += winnings
                user_data['total_won'] += winnings
                result = f"ğŸ‰ Dealer BUST! You win ${winnings:.2f}!"
            elif player_value > dealer_value:
                winnings = bet_amount
                user_data['balance'] += winnings
                user_data['total_won'] += winnings
                result = f"ğŸ‰ You WIN! +${winnings:.2f}"
            elif player_value == dealer_value:
                result = "ğŸ¤ PUSH! Bet returned."
            else:
                user_data['balance'] -= bet_amount
                result = f"ğŸ˜” Dealer wins. -${bet_amount:.2f}"
            
            user_data['total_wagered'] += bet_amount
            user_data['games_played'] += 1
            
            msg = (
                f"ğŸƒ <b>BLACKJACK - FINAL</b>\n\n"
                f"Your cards: {' '.join(player_cards)} = {player_value}\n"
                f"Dealer: {' '.join(dealer_cards)} = {dealer_value}\n\n"
                f"{result}\n"
                f"ğŸ’³ Balance: ${user_data['balance']:.2f}"
            )
            await query.edit_message_text(msg, parse_mode='HTML')
            del context.user_data['blackjack_hand']
        
        else:
            # Initial bet amount
            amount = int(data.split("_")[1])
            
            if user_data['balance'] < amount:
                await query.edit_message_text(
                    f"âŒ Insufficient balance.\nğŸ’° You have: ${user_data['balance']:.2f}\n\n"
                    f"ğŸ’¡ Use /bonus to get free money!"
                )
                return
            
            # Deal initial cards
            player_cards = [BlackjackGame.deal_card(), BlackjackGame.deal_card()]
            dealer_cards = [BlackjackGame.deal_card(), BlackjackGame.deal_card()]
            
            player_value = BlackjackGame.calculate_hand_value(player_cards)
            dealer_value = BlackjackGame.calculate_hand_value(dealer_cards)
            
            # Check for blackjacks
            if BlackjackGame.is_blackjack(player_cards):
                if BlackjackGame.is_blackjack(dealer_cards):
                    # Both blackjack - push
                    user_data['games_played'] += 1
                    msg = (
                        f"ğŸƒ <b>BLACKJACK</b>\n\n"
                        f"Your cards: {' '.join(player_cards)} = BLACKJACK!\n"
                        f"Dealer: {' '.join(dealer_cards)} = BLACKJACK!\n\n"
                        f"ğŸ¤ PUSH! Both have blackjack.\n"
                        f"ğŸ’³ Balance: ${user_data['balance']:.2f}"
                    )
                else:
                    # Player blackjack - 3:2 payout
                    winnings = amount * 1.5
                    user_data['balance'] += winnings
                    user_data['total_won'] += winnings
                    user_data['games_played'] += 1
                    msg = (
                        f"ğŸƒ <b>BLACKJACK</b>\n\n"
                        f"Your cards: {' '.join(player_cards)} = BLACKJACK!\n"
                        f"Dealer: {' '.join(dealer_cards)}\n\n"
                        f"ğŸ° BLACKJACK! You win ${winnings:.2f}!\n"
                        f"ğŸ’³ Balance: ${user_data['balance']:.2f}"
                    )
                await query.edit_message_text(msg, parse_mode='HTML')
                return
            
            elif BlackjackGame.is_blackjack(dealer_cards):
                # Dealer blackjack
                user_data['balance'] -= amount
                user_data['total_wagered'] += amount
                user_data['games_played'] += 1
                msg = (
                    f"ğŸƒ <b>BLACKJACK</b>\n\n"
                    f"Your cards: {' '.join(player_cards)} = {player_value}\n"
                    f"Dealer: {' '.join(dealer_cards)} = BLACKJACK!\n\n"
                    f"ğŸ˜” Dealer has blackjack. You lose ${amount:.2f}\n"
                    f"ğŸ’³ Balance: ${user_data['balance']:.2f}"
                )
                await query.edit_message_text(msg, parse_mode='HTML')
                return
            
            # Normal play
            keyboard = [
                [InlineKeyboardButton("ğŸ´ Hit", callback_data="blackjack_hit"),
                 InlineKeyboardButton("âœ‹ Stand", callback_data="blackjack_stand")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            
            msg = (
                f"ğŸƒ <b>BLACKJACK</b>\n\n"
                f"ğŸ’° Bet: ${amount}\n\n"
                f"Your cards: {' '.join(player_cards)} = {player_value}\n"
                f"Dealer: {dealer_cards[0]} ?\n\n"
                f"What's your move?"
            )
            
            # Store game state
            context.user_data['blackjack_hand'] = {
                'player_cards': player_cards,
                'dealer_cards': dealer_cards,
                'bet': amount
            }
            
            await query.edit_message_text(msg, reply_markup=reply_markup, parse_mode='HTML')


async def handle_text_bet(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle text-based bet inputs"""
    user_id = update.effective_user.id
    user_data = db.get_user(user_id)
    text = update.message.text.strip()
    
    game_state = context.user_data.get('game_state', {})
    
    if not game_state:
        return  # No active game
    
    game_type = game_state.get('type')
    
    try:
        amount = float(text)
        
        if amount <= 0:
            await update.message.reply_text("âŒ Amount must be greater than 0.")
            return
        
        if amount > user_data['balance']:
            await update.message.reply_text(
                f"âŒ Insufficient balance.\nğŸ’° You have: ${user_data['balance']:.2f}\n\n"
                f"ğŸ’¡ Use /bonus to get free money!"
            )
            return
        
        # Process based on game type
        if game_type == 'roulette':
            bet_type = game_state['bet_type']
            
            # Spin the wheel
            await update.message.reply_text("ğŸ° Spinning the wheel...")
            await asyncio.sleep(2)
            
            result = RouletteGame.spin()
            color = RouletteGame.get_color(result)
            payout = RouletteGame.calculate_payout(bet_type, None, result, amount)
            
            if payout > 0:
                user_data['balance'] += payout
                user_data['total_won'] += payout
                msg = (
                    f"ğŸ° Wheel lands on {color} <b>{result}</b>!\n\n"
                    f"ğŸ‰ YOU WIN ${payout:.2f}!\n"
                    f"ğŸ’³ Balance: ${user_data['balance']:.2f}"
                )
            else:
                user_data['balance'] -= amount
                msg = (
                    f"ğŸ° Wheel lands on {color} <b>{result}</b>!\n\n"
                    f"ğŸ˜” You lose ${amount:.2f}\n"
                    f"ğŸ’³ Balance: ${user_data['balance']:.2f}"
                )
            
            user_data['total_wagered'] += amount
            user_data['games_played'] += 1
            
            await update.message.reply_text(msg, parse_mode='HTML')
            context.user_data['game_state'] = {}
        
        elif game_type == 'basketball':
            prediction = game_state['prediction']
            
            await update.message.reply_text("ğŸ€ Taking the shot...")
            await asyncio.sleep(2)
            
            result = BasketballGame.shoot()
            payout = BasketballGame.calculate_payout(prediction, result, amount)
            
            result_emoji = "ğŸ€ SCORES!" if result else "âŒ MISS!"
            
            if payout > 0:
                user_data['balance'] += payout
                user_data['total_won'] += payout
                msg = (
                    f"ğŸ€ Shot result: {result_emoji}\n\n"
                    f"ğŸ‰ YOU WIN ${payout:.2f}!\n"
                    f"ğŸ’³ Balance: ${user_data['balance']:.2f}"
                )
            else:
                user_data['balance'] -= amount
                msg = (
                    f"ğŸ€ Shot result: {result_emoji}\n\n"
                    f"ğŸ˜” You lose ${amount:.2f}\n"
                    f"ğŸ’³ Balance: ${user_data['balance']:.2f}"
                )
            
            user_data['total_wagered'] += amount
            user_data['games_played'] += 1
            
            await update.message.reply_text(msg, parse_mode='HTML')
            context.user_data['game_state'] = {}
        
        elif game_type == 'soccer':
            prediction = game_state['prediction']
            
            await update.message.reply_text("âš½ Taking the penalty kick...")
            await asyncio.sleep(2)
            
            result = SoccerGame.kick()
            payout = SoccerGame.calculate_payout(prediction, result, amount)
            
            result_emoji = "âš½ GOAL!" if result else "ğŸ§¤ SAVED!"
            
            if payout > 0:
                user_data['balance'] += payout
                user_data['total_won'] += payout
                msg = (
                    f"âš½ Kick result: {result_emoji}\n\n"
                    f"ğŸ‰ YOU WIN ${payout:.2f}!\n"
                    f"ğŸ’³ Balance: ${user_data['balance']:.2f}"
                )
            else:
                user_data['balance'] -= amount
                msg = (
                    f"âš½ Kick result: {result_emoji}\n\n"
                    f"ğŸ˜” You lose ${amount:.2f}\n"
                    f"ğŸ’³ Balance: ${user_data['balance']:.2f}"
                )
            
            user_data['total_wagered'] += amount
            user_data['games_played'] += 1
            
            await update.message.reply_text(msg, parse_mode='HTML')
            context.user_data['game_state'] = {}
        
        elif game_type == 'bowling':
            prediction = game_state['prediction']
            
            await update.message.reply_text("ğŸ³ Rolling the ball...")
            await asyncio.sleep(2)
            
            result = BowlingGame.roll()
            payout = BowlingGame.calculate_payout(prediction, result, amount)
            
            result_emojis = {
                'strike': 'ğŸ³ STRIKE!',
                'spare': 'ğŸ“ Spare!',
                'miss': 'âŒ Miss!'
            }
            result_text = result_emojis[result]
            
            if payout > 0:
                user_data['balance'] += payout
                user_data['total_won'] += payout
                
                # Check for jackpot (simplified - 3 strikes)
                jackpot_msg = ""
                if result == 'strike' and prediction == 'strike':
                    strikes = context.user_data.get('strike_count', 0) + 1
                    context.user_data['strike_count'] = strikes
                    
                    if strikes >= 3:
                        jackpot_win = db.jackpot_pool
                        user_data['balance'] += jackpot_win
                        jackpot_msg = f"\n\nğŸ†ğŸ’° JACKPOT! You win ${jackpot_win:.2f}! ğŸ’°ğŸ†"
                        db.jackpot_pool = 5000.0  # Reset
                        context.user_data['strike_count'] = 0
                else:
                    context.user_data['strike_count'] = 0
                
                msg = (
                    f"ğŸ³ Roll result: {result_text}\n\n"
                    f"ğŸ‰ YOU WIN ${payout:.2f}!{jackpot_msg}\n"
                    f"ğŸ’³ Balance: ${user_data['balance']:.2f}"
                )
            else:
                user_data['balance'] -= amount
                context.user_data['strike_count'] = 0
                msg = (
                    f"ğŸ³ Roll result: {result_text}\n\n"
                    f"ğŸ˜” You lose ${amount:.2f}\n"
                    f"ğŸ’³ Balance: ${user_data['balance']:.2f}"
                )
            
            user_data['total_wagered'] += amount
            user_data['games_played'] += 1
            db.jackpot_pool += amount * 0.01  # 1% to jackpot
            
            await update.message.reply_text(msg, parse_mode='HTML')
            context.user_data['game_state'] = {}
    
    except (ValueError, IndexError):
        await update.message.reply_text(
            "âŒ Invalid format. Please enter just the bet amount.\n\n"
            "Example: 10"
        )


async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle /help command"""
    help_text = (
        "ğŸ° <b>CASINO EMOJIA - COMMANDS</b>\n\n"
        "<b>ğŸ’° Banking:</b>\n"
        "/bonus - Get daily free money! ğŸ\n"
        "/balance - Check your balance\n"
        "/deposit - Add LTC funds\n"
        "/confirm [txid] - Confirm deposit\n"
        "/withdraw [amount] - Cash out\n\n"
        "<b>ğŸ® Games:</b>\n"
        "/roulette - Classic roulette ğŸ°\n"
        "/blackjack - 21 card game ğŸƒ\n"
        "/basketball - Free throw bets ğŸ€\n"
        "/soccer - Penalty kick bets âš½\n"
        "/bowling - Bowling jackpot ğŸ³\n\n"
        "<b>ğŸ† Other:</b>\n"
        "/leaderboard - Top players\n"
        "/help - Show this message\n\n"
        "ğŸ’¡ <b>Quick Start:</b>\n"
        "1. /bonus (get free money)\n"
        "2. /roulette (play a game)\n"
        "3. Click a button, then type your bet\n\n"
        "Good luck! ğŸ€"
    )
    await update.message.reply_text(help_text, parse_mode='HTML')


# ==================== MAIN FUNCTION ====================
def main():
    """Start the bot"""
    print("=" * 50)
    print("ğŸ° CASINO EMOJIA BOT")
    print("=" * 50)
    print(f"Bot: @kirinkasinobot")
    print(f"Owner: @blackisraelite")
    print("=" * 50)
    print("\nğŸš€ Starting bot...")
    
    # Create application
    application = Application.builder().token(BOT_TOKEN).build()
    
    # Add command handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("help", help_command))
    application.add_handler(CommandHandler("deposit", deposit))
    application.add_handler(CommandHandler("confirm", confirm_deposit))
    application.add_handler(CommandHandler("balance", balance))
    application.add_handler(CommandHandler("withdraw", withdraw))
    application.add_handler(CommandHandler("roulette", roulette_command))
    application.add_handler(CommandHandler("blackjack", blackjack_command))
    application.add_handler(CommandHandler("basketball", basketball_command))
    application.add_handler(CommandHandler("soccer", soccer_command))
    application.add_handler(CommandHandler("bowling", bowling_command))
    application.add_handler(CommandHandler("leaderboard", leaderboard))
    application.add_handler(CommandHandler("bonus", daily_bonus))
    
    # Add callback handler for buttons
    application.add_handler(CallbackQueryHandler(handle_callback))
    
    # Add text handler for bet inputs
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_text_bet))
    
    # Start the bot
    print("âœ… Bot is running!")
    print("ğŸ“± Open Telegram and message @kirinkasinobot")
    print("ğŸ’¬ Send /start to begin")
    print("\nâš ï¸  Keep this terminal window open!")
    print("ğŸ›‘ Press Ctrl+C to stop the bot\n")
    
    application.run_polling(allowed_updates=Update.ALL_TYPES)


if __name__ == "__main__":
    main()